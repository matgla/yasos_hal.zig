//
// build.zig
//
// Copyright (C) 2024 Mateusz Stadnik <matgla@live.com>
//
// This program is free software: you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation, either version
// 3 of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied
// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
// PURPOSE. See the GNU General Public License for more details.
//
// You should have received a copy of the GNU General
// Public License along with this program. If not, see
// <https://www.gnu.org/licenses/>.
//

const std = @import("std");
const buildin = @import("builtin");

const Config = struct {
    cpu: ?[]const u8 = null,
    linker_script_path: ?[]const u8 = null,
    bundle_compiler_rt: ?bool = false,
};

fn load_config(b: *std.Build, config_file: []const u8) !Config {
    const file = try std.fs.openFileAbsolute(config_file, .{ .mode = .read_only });
    defer file.close();

    const data = try file.readToEndAlloc(b.allocator, 4096);
    const parsed = try std.json.parseFromSlice(
        Config,
        b.allocator,
        data,
        .{
            .ignore_unknown_fields = true,
        },
    );
    return parsed.value;
}

pub fn build(b: *std.Build) !void {
    // build system dependency
    const board = b.option([]const u8, "board", "a board for which the HAL is used") orelse "host";
    const exec_name = b.option([]const u8, "name", "application name for which HAL is used") orelse unreachable;
    const root_file = b.option([]const u8, "root_file", "application root file") orelse unreachable;
    const config_file = b.option([]const u8, "config_file", "path to config.json file generated by KConfig") orelse unreachable;

    const optimize = b.standardOptimizeOption(.{});
    std.log.info("Used board - {s}", .{board});

    const builder = Builder{};
    try builder.configureBoard(b, @as([]const u8, board), @as([]const u8, exec_name), root_file, optimize, @as([]const u8, config_file));
}

fn replace_tokens(b: *std.Build, linker_script: []const u8) []u8 {
    const token_position = std.mem.indexOf(u8, linker_script, "${");
    var path: []u8 = b.fmt("{s}", .{linker_script});
    while (token_position) |start_position| {
        const hal_root = b.build_root.path.?;
        const end_position = std.mem.indexOf(u8, path, "}");
        if (end_position) |end| {
            const token = path[start_position + 2 .. end];
            if (std.mem.eql(u8, token, "hal_root")) {
                path = b.fmt("{s}{s}{s}", .{ path[0..start_position], hal_root, path[end + 1 ..] });
            } else {
                unreachable;
            }
        } else {
            return path;
        }
    }
    return path;
}

pub const Builder = struct {
    pub fn configureBoard(_: *const Builder, b: *std.Build, board: []const u8, execName: []const u8, root_file: []const u8, optimize: std.builtin.OptimizeMode, config_file: []const u8) !void {
        const boardDependency = try std.fmt.allocPrint(b.allocator, "boards/{s}/{s}.zig", .{ board, board });
        defer b.allocator.free(boardDependency);

        const config = try load_config(b, config_file);

        if (config.cpu == null) {
            std.log.err("No CPU entry in config.json", .{});
            return;
        }
        const halDependency = try std.fmt.allocPrint(b.allocator, "mcu/{s}", .{config.cpu.?});
        defer b.allocator.free(halDependency);
        const mcu = b.dependency(halDependency, .{});

        const root_path = std.Build.LazyPath{ .src_path = .{
            .sub_path = root_file,
            .owner = b,
        } };

        if (mcu.module("hal").resolved_target) |target| {
            const boardModule = b.addModule("board", .{
                .root_source_file = b.path(boardDependency),
                .target = target,
                .optimize = optimize,
            });
            boardModule.addImport("hal", mcu.module("hal"));

            const exe = b.addExecutable(.{
                .name = execName,
                .root_source_file = root_path,
                .target = target,
                .optimize = optimize,
            });
            exe.want_lto = false;
            exe.root_module.addImport("board", boardModule);
            exe.root_module.addImport("hal", mcu.module("hal"));
            if (config.linker_script_path) |linker_script| {
                const linker = replace_tokens(b, linker_script);
                defer b.allocator.free(linker);
                const path = std.Build.LazyPath{
                    .cwd_relative = linker,
                };
                exe.setLinkerScript(path);
            }

            if (config.bundle_compiler_rt) |bundle_compiler_rt| {
                exe.bundle_compiler_rt = bundle_compiler_rt;
            }

            b.installArtifact(exe);
        }
    }
};
